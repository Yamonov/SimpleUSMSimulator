<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>USM簡易シミュレーター</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #fff;
            margin: 0;
            padding: 0;
            font-size: 75%;
        }

        .container {
            width: 96vw;
            max-width: none;
            margin-left: 2vw;
            margin-right: 2vw;
            margin-top: 20px;
            padding: 0;
            border-radius: 0;
            box-sizing: border-box;
            box-shadow: none;
            background-color: #fff;
        }

        .controls {
            display: flex;
            gap: 20px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .controls-left,
        .controls-right {
            flex: 1 1 320px;
            min-width: 320px;
            display: flex;
            flex-direction: column;
        }

        .controls-left {
            gap: 20px;
        }

        .controls-right {
            gap: 20px;
        }

        .control-group {
            background-color: #f8f8f8;
            padding: 8px;
            border-radius: 8px;
            border: 1px solid #ddd;
        }

        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: #555;
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 6px;
            flex-wrap: wrap;
            min-height: 24px;
        }

        input[type="range"] {
            flex: 1;
            height: 6px;
            background: #ddd;
            border-radius: 2px;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 32px;
            height: 32px;
            background: #4CAF50;
            border-radius: 50%;
            cursor: pointer;
        }

        input[type="range"]::-moz-range-thumb {
            width: 32px;
            height: 32px;
            background: #4CAF50;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        /* 目印ライン付きレンジ（300/350/400に縦線） */
        .range-with-marks {
            background:
                linear-gradient(#888, #888) 25% 50% / 1px 100% no-repeat,
                linear-gradient(#888, #888) 37.5% 50% / 1px 100% no-repeat,
                linear-gradient(#888, #888) 50% 50% / 1px 100% no-repeat;
        }

        .resolution-scale {
            margin-top: 8px;
        }

        .resolution-scale-labels {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            font-size: 12px;
            color: #666;
            text-align: center;
            letter-spacing: 0.5px;
        }

        .resolution-scale-note {
            font-size: 12px;
            color: #666;
            text-align: center;
            margin-top: 4px;
        }

        .resolution-visibility-bar {
            --visible-color: #d95c57;
            --invisible-color: #36a84f;
            --boundary-start: 50%;
            --boundary-end: 50%;
            height: 12px;
            border-radius: 6px;
            border: 1px solid #ccc;
            margin-top: 4px;
            background-color: var(--visible-color);
        }

        .resolution-visibility-bar[data-mode="mixed"] {
            background: linear-gradient(90deg,
                    var(--invisible-color) 0%,
                    var(--invisible-color) var(--boundary-start),
                    var(--visible-color) var(--boundary-end),
                    var(--visible-color) 100%);
        }

        .resolution-visibility-bar[data-mode="visible"] {
            background-color: var(--visible-color);
        }

        .resolution-visibility-bar[data-mode="invisible"] {
            background-color: var(--invisible-color);
        }

        /* 値表示の体裁を統一 */
        .value-display {
            min-width: 40px;
            text-align: center;
            background-color: white;
            display: inline-block;
            height: 32px;
            line-height: 28px;
            font-size: 20px;
            padding: 2px 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            vertical-align: middle;
        }

        .density-inputs {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .density-box {
            width: 30px;
            height: 32px;
            border-radius: 6px;
            border: 1px solid #ccc;
            box-sizing: border-box;
            margin-left: 8px;
            display: inline-block;
            vertical-align: middle;
        }

        .density-input {
            display: grid;
            grid-template-columns: 72px 1fr auto auto;
            align-items: center;
            gap: 8px;
        }

        .density-input label {
            text-align: right;
        }

        .density-input input[type="range"] {
            min-width: 120px;
        }

        /* 数値入力型の value-display を他と同じ見た目に */
        input.value-display[type="number"] {
            width: 60px;
            text-align: center;
            font-size: 20px;
            height: 32px;
            line-height: 28px;
            -moz-appearance: textfield;
            font-variant-numeric: tabular-nums;
            font-feature-settings: "tnum";
        }

        /* WebKit: スピンボタン非表示 */
        input.value-display[type="number"]::-webkit-outer-spin-button,
        input.value-display[type="number"]::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        .canvas-container {
            text-align: center;
            width: 100%;
            min-width: 320px;
            margin-top: 20px;
        }

        canvas {
            width: 100%;
            max-width: 100%;
            display: block;
            box-sizing: border-box;
            margin: 0 auto;
            border: 2px solid #333;
            border-radius: 8px;
            background-color: white;
        }

        #graphCanvas {
            width: 100%;
            display: block;
        }

        .usm-items {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        @media (min-width: 800px) {
            .density-box {
                height: 36px;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="controls">
            <div class="controls-left">
                <div class="control-group">
                    <div class="density-inputs">
                        <div class="density-input">
                            <label for="startDensity">開始濃度</label>
                            <input type="range" id="startDensity" min="0" max="255" value="50" step="1" tabindex="-1">
                            <input type="number" class="value-display" id="startDensityValue" min="0" max="255" step="1"
                                value="50" tabindex="1">
                            <div class="density-box" id="startDensityBox"></div>
                        </div>
                        <div class="density-input">
                            <label for="endDensity">終了濃度</label>
                            <input type="range" id="endDensity" min="0" max="255" value="200" step="1" tabindex="-1">
                            <input type="number" class="value-display" id="endDensityValue" min="0" max="255" step="1"
                                value="200" tabindex="2">
                            <div class="density-box" id="endDensityBox"></div>
                        </div>
                    </div>
                </div>
                <div class="control-group">
                    <label>解像度（1px:<span id="resolutionPxSize">0.000</span>mm）</label>
                    <div class="slider-container">
                        <input type="range" id="resolution" class="range-with-marks" min="200" max="600" step="50"
                            value="350" tabindex="-1">
                        <input type="number" class="value-display" id="resolutionValue" min="200" max="600" step="50"
                            value="350" tabindex="3">
                    </div>
                    <div class="resolution-scale">
                        <div class="resolution-scale-labels" aria-hidden="true">
                            <span>1px</span>
                            <span>2px</span>
                        </div>
                        <div class="resolution-visibility-bar" id="resolutionVisibilityBar" data-mode="mixed"></div>
                        <div class="resolution-scale-note">※視力1.0で25cm距離では、緑部分は見えません</div>
                    </div>
                </div>
            </div>
            <div class="controls-right">
                <div class="control-group">
                    <label>USM設定</label>
                    <div class="usm-items">
                        <div>
                            <label>強さ (Amount)</label>
                            <div class="slider-container">
                                <input type="range" id="amount" min="0" max="500" value="100" step="1" tabindex="-1">
                                <input type="number" class="value-display" id="amountValue" min="0" max="500"
                                    value="100" tabindex="4">
                            </div>
                        </div>
                        <div>
                            <label>半径 (Radius)</label>
                            <div class="slider-container">
                                <input type="range" id="radius" min="0.1" max="5" step="0.1" value="1" tabindex="-1">
                                <input type="number" class="value-display" id="radiusValue" min="0.1" max="5" step="0.1"
                                    value="1.0" tabindex="5">
                            </div>
                        </div>
                        <div>
                            <label>閾値 (Threshold)</label>
                            <div class="slider-container">
                                <input type="range" id="threshold" min="0" max="50" value="0" tabindex="-1">
                                <input type="number" class="value-display" id="thresholdValue" min="0" max="50"
                                    value="0" tabindex="6">
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="canvas-container">
            <canvas id="graphCanvas"></canvas>
        </div>
    </div>

    <script>
        // 要素取得
        const canvas = document.getElementById('graphCanvas');
        const ctx = canvas.getContext('2d');

        // コントロール要素
        const startDensityInput = document.getElementById('startDensity');
        const endDensityInput = document.getElementById('endDensity');
        const amountSlider = document.getElementById('amount');
        const radiusSlider = document.getElementById('radius');
        const thresholdSlider = document.getElementById('threshold');
        const resolutionSlider = document.getElementById('resolution');

        // 値表示要素
        const startDensityValue = document.getElementById('startDensityValue');
        const endDensityValue = document.getElementById('endDensityValue');
        const amountValue = document.getElementById('amountValue');
        const radiusValue = document.getElementById('radiusValue');
        const thresholdValue = document.getElementById('thresholdValue');
        const resolutionValue = document.getElementById('resolutionValue');
        const resolutionPxSize = document.getElementById('resolutionPxSize');
        const resolutionVisibilityBar = document.getElementById('resolutionVisibilityBar');

        // 濃度ボックス要素
        const startDensityBox = document.getElementById('startDensityBox');
        const endDensityBox = document.getElementById('endDensityBox');

        // キャンバスサイズ調整
        function resizeCanvas() {
            const container = canvas.parentElement;
            const dpr = window.devicePixelRatio || 1;
            const rect = container.getBoundingClientRect();
            const width = Math.floor(rect.width);

            const viewportHeight = window.innerHeight;
            const controlsHeight = document.querySelector('.controls').offsetHeight;
            const marginTop = 20;
            const extraMargin = 40;

            const availableHeight = viewportHeight - controlsHeight - marginTop - extraMargin;

            const aspectRatio = 0.6;
            const heightByAspect = width * aspectRatio;
            const height = Math.min(600, Math.max(200, Math.min(availableHeight, heightByAspect)));

            canvas.width = width * dpr;
            canvas.height = height * dpr;
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';

            ctx.scale(dpr, dpr);
        }

        // ガウシアンブラーのカーネル係数を生成
        function gaussianKernel(radius) {
            // 半径をsigma(ピクセル)として扱い、実効値を少し上げる
            const sigma = Math.max(0.01, radius * 1.09);
            const kernelRadius = Math.ceil(sigma * 3);
            const size = kernelRadius * 2 + 1;
            const kernel = [];
            let sum = 0;

            for (let i = -kernelRadius; i <= kernelRadius; i++) {
                const value = Math.exp(-(i * i) / (2 * sigma * sigma));
                kernel[i + kernelRadius] = value;
                sum += value;
            }
            for (let i = 0; i < size; i++) kernel[i] /= sum;
            return kernel;
        }

        // USMを適用
        function applyUSM(originalValue, blurredValue, amount, threshold) {
            const blurredQ = Math.round(blurredValue);
            const difference = originalValue - blurredQ;
            const absDiff = Math.abs(difference);
            const thresholdAdj = threshold * 0.5;
            const adjustedDiff = absDiff <= thresholdAdj ? 0 : Math.sign(difference) * (absDiff - thresholdAdj);
            const enhancedValue = originalValue + (amount / 100.0) * adjustedDiff;
            return Math.max(0, Math.min(255, Math.round(enhancedValue)));
        }

        // エッジを生成し、ぼかしを適用
        function createBlurredEdge(startDensity, endDensity, radius) {
            const width = 20;
            const gradient = [];
            const edgePosition = width / 2;

            for (let x = 0; x < width; x++) {
                const value = x < edgePosition ? startDensity : endDensity;
                gradient[x] = value;
            }

            const kernel = gaussianKernel(radius);
            const blurred = [];
            const kernelRadius = Math.floor(kernel.length / 2);

            for (let x = 0; x < width; x++) {
                let sum = 0, weightSum = 0;
                for (let k = 0; k < kernel.length; k++) {
                    const sampleX = x + k - kernelRadius;
                    const sampleValue =
                        sampleX < 0 ? gradient[0] :
                            sampleX >= width ? gradient[width - 1] :
                                gradient[sampleX];
                    sum += sampleValue * kernel[k];
                    weightSum += kernel[k];
                }
                blurred[x] = sum / weightSum;
            }
            return { original: gradient, blurred: blurred };
        }

        // グラフ描画
        function drawGraph() {
            resizeCanvas();

            // パラメータ取得
            const startDensity = parseInt(startDensityInput.value);
            const endDensity = parseInt(endDensityInput.value);
            const amount = parseInt(amountSlider.value);
            const radius = parseFloat(radiusSlider.value);
            const threshold = parseInt(thresholdSlider.value);
            const ppi = parseInt(resolutionSlider.value) || 300;
            const mmPerPx = 25.4 / ppi;

            // 値を表示
            startDensityValue.value = startDensity;
            endDensityValue.value = endDensity;
            amountValue.value = amount;
            radiusValue.value = radius.toFixed(1);
            thresholdValue.value = threshold;
            resolutionValue.value = ppi;
            resolutionPxSize.textContent = mmPerPx.toFixed(3);

            const acuityMm = Math.tan(Math.PI / 10800) * 250;
            const scaleMin = 1;
            const scaleMax = 2;
            const scaleRange = scaleMax - scaleMin;
            const boundaryPx = acuityMm / mmPerPx;
            const gradientWidth = 0.5;
            const gradientStartPx = boundaryPx - (gradientWidth / 2) + 0.5;
            const gradientEndPx = gradientStartPx + gradientWidth;
            let start = (gradientStartPx - scaleMin) / scaleRange;
            let end = (gradientEndPx - scaleMin) / scaleRange;
            start = Math.max(0, Math.min(1, start));
            end = Math.max(0, Math.min(1, end));

            if (boundaryPx <= scaleMin) {
                resolutionVisibilityBar.dataset.mode = 'visible';
            } else if (boundaryPx >= scaleMax) {
                resolutionVisibilityBar.dataset.mode = 'invisible';
            } else {
                resolutionVisibilityBar.dataset.mode = 'mixed';
            }
            resolutionVisibilityBar.style.setProperty('--boundary-start', (start * 100).toFixed(2) + '%');
            resolutionVisibilityBar.style.setProperty('--boundary-end', (end * 100).toFixed(2) + '%');

            // 濃度ボックスの色
            startDensityBox.style.background = `rgb(${startDensity},${startDensity},${startDensity})`;
            endDensityBox.style.background = `rgb(${endDensity},${endDensity},${endDensity})`;

            // キャンバスクリア
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // エッジ・ぼかし
            const { original, blurred } = createBlurredEdge(startDensity, endDensity, radius);

            // USM適用
            const sharpened = [];
            for (let x = 0; x < original.length; x++) {
                sharpened[x] = applyUSM(original[x], blurred[x], amount, threshold);
            }

            // 変化量（0–12）
            const change = [];
            for (let x = 0; x < original.length; x++) {
                const delta = Math.abs(sharpened[x] - original[x]);
                change[x] = (delta / 255) * 12;
            }

            // 半値幅（左/右）と全幅を算出（px）
            function computeHalfWidths(arr) {
                if (!arr || arr.length < 2) return { left: 0, right: 0, full: 0 };
                const maxVal = Math.max(...arr);
                if (maxVal <= 0) return { left: 0, right: 0, full: 0 };
                const half = maxVal / 2;

                // 最大値が連続する場合の中心を使う
                let peakLeft = 0;
                let peakRight = arr.length - 1;
                for (let i = 0; i < arr.length; i++) {
                    if (arr[i] === maxVal) { peakLeft = i; break; }
                }
                for (let i = arr.length - 1; i >= 0; i--) {
                    if (arr[i] === maxVal) { peakRight = i; break; }
                }
                const peakCenter = (peakLeft + peakRight) / 2;

                // 半値を初めて超える位置（左/右）
                let leftmostAbove = -1;
                let rightmostAbove = -1;
                for (let i = 0; i < arr.length; i++) {
                    if (arr[i] >= half) { leftmostAbove = i; break; }
                }
                for (let i = arr.length - 1; i >= 0; i--) {
                    if (arr[i] >= half) { rightmostAbove = i; break; }
                }

                const eps = 1e-6;
                const leftHasNonZero = peakLeft > 0 && arr.slice(0, peakLeft).some(v => v > eps);
                const rightHasNonZero = peakRight < arr.length - 1 && arr.slice(peakRight + 1).some(v => v > eps);

                // 左交点（半値超えが無い場合は0幅扱い）
                let xL = 0;
                if (leftmostAbove === -1 || !leftHasNonZero) {
                    xL = peakCenter;
                } else if (leftmostAbove <= 0) {
                    xL = 0;
                } else {
                    const y0 = arr[leftmostAbove - 1];
                    const y1 = arr[leftmostAbove];
                    const t = (half - y0) / ((y1 - y0) || 1e-9);
                    xL = (leftmostAbove - 1) + Math.max(0, Math.min(1, t));
                }

                // 右交点（半値超えが無い場合は0幅扱い）
                let xR = arr.length - 1;
                if (rightmostAbove === -1 || !rightHasNonZero) {
                    xR = peakCenter;
                } else if (rightmostAbove >= arr.length - 1) {
                    xR = arr.length - 1;
                } else {
                    const y0 = arr[rightmostAbove];
                    const y1 = arr[rightmostAbove + 1];
                    const t = (half - y0) / ((y1 - y0) || 1e-9);
                    xR = rightmostAbove + Math.max(0, Math.min(1, t));
                }

                const left = Math.max(0, peakCenter - xL);
                const right = Math.max(0, xR - peakCenter);
                const full = Math.max(0, xR - xL);
                return { left, right, full };
            }
            const halfWidthsPx = computeHalfWidths(change);
            const leftHalfMm = halfWidthsPx.left * mmPerPx;
            const rightHalfMm = halfWidthsPx.right * mmPerPx;
            const fwhmMm = halfWidthsPx.full * mmPerPx;

            // グラフ領域
            const padX = 40, padY = 40;
            const graphWidth = canvas.width / (window.devicePixelRatio || 1) - padX * 2;
            const graphHeight = canvas.height / (window.devicePixelRatio || 1) - padY * 2;
            const graphX = padX, graphY = padY;

            // 背景
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1;

            const cellWidth = graphWidth / 20;
            for (let i = 0; i < sharpened.length; i++) {
                const grayValue = Math.round(sharpened[i]);
                ctx.fillStyle = `rgb(${grayValue}, ${grayValue}, ${grayValue})`;
                const cellLeft = graphX + i * cellWidth;
                const cellRight = graphX + (i + 1) * cellWidth;
                ctx.fillRect(cellLeft, graphY, cellRight - cellLeft, graphHeight);
            }

            // グリッド
            for (let i = 0; i <= 10; i++) {
                const y = graphY + (graphHeight / 10) * i;
                ctx.beginPath(); ctx.moveTo(graphX, y); ctx.lineTo(graphX + graphWidth, y); ctx.stroke();
            }
            for (let i = 0; i <= 20; i++) {
                const x = graphX + (graphWidth / 20) * i;
                ctx.beginPath(); ctx.moveTo(x, graphY); ctx.lineTo(x, graphY + graphHeight); ctx.stroke();
            }

            // 軸
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(graphX, graphY);
            ctx.lineTo(graphX, graphY + graphHeight);
            ctx.lineTo(graphX + graphWidth, graphY + graphHeight);
            ctx.stroke();

            // X軸ラベル：半値幅
            ctx.fillStyle = '#333';
            ctx.font = '20px Arial';
            const baseX = graphX + graphWidth / 2;
            const baseY = graphY + graphHeight + 35;
            const leftText = leftHalfMm.toFixed(3);
            const rightText = rightHalfMm.toFixed(3);
            const fullText = '（全幅：' + fwhmMm.toFixed(3) + ' mm）';
            const gap = 10;

            ctx.textAlign = 'right';
            ctx.fillText(leftText, baseX - gap, baseY);
            ctx.textAlign = 'center';
            ctx.fillText('｜', baseX, baseY);
            ctx.textAlign = 'left';
            ctx.fillText(rightText, baseX + gap, baseY);
            const rightWidth = ctx.measureText(rightText).width;
            ctx.fillText(fullText, baseX + gap + rightWidth + 16, baseY);

            // X目盛り（0,5,10,15,20）
            ctx.fillStyle = '#666';
            ctx.font = '10px Arial';
            ctx.textAlign = 'center';
            for (let i = 0; i <= 20; i += 5) {
                const x = graphX + (graphWidth / 20) * i;
                ctx.fillText(i.toString(), x, graphY + graphHeight + 15);
            }

            // 左Y軸目盛り（濃度 0〜255）
            ctx.textAlign = 'right';
            for (let i = 0; i <= 255; i += 51) {
                const y = graphY + graphHeight - (i / 255) * graphHeight;
                ctx.fillText(i.toString(), graphX - 5, y + 3);
            }

            // 線描画（0–255）
            function drawLine(data, color, lineWidth = 2, outline = false) {
                if (outline) {
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = lineWidth + 4;
                    ctx.beginPath();
                    for (let i = 0; i < data.length; i++) {
                        const x = graphX + (graphWidth / (data.length - 1)) * i;
                        const y = graphY + graphHeight - (data[i] / 255) * graphHeight;
                        if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
                    }
                    ctx.stroke();
                }
                ctx.strokeStyle = color;
                ctx.lineWidth = lineWidth;
                ctx.beginPath();
                for (let i = 0; i < data.length; i++) {
                    const x = graphX + (graphWidth / (data.length - 1)) * i;
                    const y = graphY + graphHeight - (data[i] / 255) * graphHeight;
                    if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
                }
                ctx.stroke();
            }

            // 任意レンジ線（0–12 用）
            function drawLineScaled(data, color, yMin, yMax, lineWidth = 2, outline = false) {
                if (outline) {
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = lineWidth + 4;
                    ctx.beginPath();
                    for (let i = 0; i < data.length; i++) {
                        const x = graphX + (graphWidth / (data.length - 1)) * i;
                        const y = graphY + graphHeight - ((data[i] - yMin) / (yMax - yMin)) * graphHeight;
                        if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
                    }
                    ctx.stroke();
                }
                ctx.strokeStyle = color;
                ctx.lineWidth = lineWidth;
                ctx.beginPath();
                for (let i = 0; i < data.length; i++) {
                    const x = graphX + (graphWidth / (data.length - 1)) * i;
                    const y = graphY + graphHeight - ((data[i] - yMin) / (yMax - yMin)) * graphHeight;
                    if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
                }
                ctx.stroke();
            }

            // 線を描画（濃度系）
            drawLine(original, '#999', 3);
            drawLine(blurred, '#87CEEB', 2, true);
            drawLine(sharpened, '#FF4444', 3, true);

            // 変化量（黒＋白フチ）
            drawLineScaled(change, 'black', 0, 12, 2, true);

            // 凡例
            const legendY = 25;
            ctx.font = '12px Arial';
            ctx.textAlign = 'left';
            ctx.fillStyle = '#999'; ctx.fillText('— 元の濃度', 80, legendY);
            ctx.fillStyle = '#87CEEB'; ctx.fillText('— ぼかした濃度', 180, legendY);
            ctx.fillStyle = '#FF4444'; ctx.fillText('— USM適用後', 300, legendY);
            ctx.fillStyle = '#000'; ctx.fillText('— 変化量', 400, legendY);
        }

        // イベント
        startDensityInput.addEventListener('input', drawGraph);
        endDensityInput.addEventListener('input', drawGraph);
        amountSlider.addEventListener('input', () => { amountValue.value = amountSlider.value; drawGraph(); });
        radiusSlider.addEventListener('input', () => { radiusValue.value = radiusSlider.value; drawGraph(); });
        thresholdSlider.addEventListener('input', () => { thresholdValue.value = thresholdSlider.value; drawGraph(); });
        resolutionSlider.addEventListener('input', () => {
            resolutionValue.value = resolutionSlider.value;
            drawGraph();
        });

        // 数値入力
        startDensityValue.addEventListener('input', () => {
            let v = Math.max(0, Math.min(255, parseInt(startDensityValue.value) || 0));
            startDensityValue.value = v; startDensityInput.value = v; drawGraph();
        });
        endDensityValue.addEventListener('input', () => {
            let v = Math.max(0, Math.min(255, parseInt(endDensityValue.value) || 0));
            endDensityValue.value = v; endDensityInput.value = v; drawGraph();
        });
        amountValue.addEventListener('input', () => {
            let v = Math.max(0, Math.min(500, parseInt(amountValue.value) || 0));
            amountValue.value = v; amountSlider.value = v; drawGraph();
        });
        radiusValue.addEventListener('change', () => {
            let v = parseFloat(radiusValue.value); if (isNaN(v)) return;
            v = Math.max(0.1, Math.min(5, v)); radiusValue.value = v; radiusSlider.value = v; drawGraph();
        });
        thresholdValue.addEventListener('input', () => {
            let v = Math.max(0, Math.min(50, parseInt(thresholdValue.value) || 0));
            thresholdValue.value = v; thresholdSlider.value = v; drawGraph();
        });
        resolutionValue.addEventListener('input', () => {
            let v = Math.max(200, Math.min(600, parseInt(resolutionValue.value) || 0));
            resolutionValue.value = v;
            resolutionSlider.value = v;
            drawGraph();
        });

        const numericInputs = document.querySelectorAll('input[type="number"].value-display');
        numericInputs.forEach((input) => {
            input.addEventListener('focus', () => input.select());
        });

        // リサイズ
        window.addEventListener('resize', drawGraph);

        // 初期描画
        drawGraph();
    </script>
</body>

</html>
