<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>USM簡易シミュレーター</title>
    <style>
        body { font-family: Arial, sans-serif; background-color: #fff; margin: 0; padding: 0; font-size: 75%; }
        .container { width: 96vw; max-width: none; margin-left: 2vw; margin-right: 2vw; margin-top: 20px; padding: 0; border-radius: 0; box-sizing: border-box; box-shadow: none; background-color: white; }
        h1 { text-align: center; color: #333; margin-bottom: 30px; }
        .controls { display: flex; gap: 20px; margin-bottom: 30px; flex-wrap: wrap; }
        .controls-left, .controls-right { flex: 1 1 320px; min-width: 320px; display: flex; flex-direction: column; }
        .controls-left { gap: 20px; }
        .controls-right { gap: 20px; }
        .control-group { background-color: #f8f8f8; padding: 8px; border-radius: 8px; border: 1px solid #ddd; }
        .control-group label { display: block; margin-bottom: 8px; font-weight: bold; color: #555; }
        .slider-container { display: flex; align-items: center; gap: 6px; flex-wrap: wrap; min-height: 24px; }
        input[type="range"] { flex: 1; height: 6px; background: #ddd; border-radius: 2px; outline: none; -webkit-appearance: none; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 32px; height: 32px; background: #4CAF50; border-radius: 50%; cursor: pointer; }
        input[type="range"]::-moz-range-thumb { width: 32px; height: 32px; background: #4CAF50; border-radius: 50%; cursor: pointer; border: none; }
        /* 目印ライン付きレンジ（300/350/400に縦線・ラベル無し）*/
        .range-with-marks {
            background:
                linear-gradient(#888, #888) 25% 50% / 1px 100% no-repeat,
                linear-gradient(#888, #888) 37.5% 50% / 1px 100% no-repeat,
                linear-gradient(#888, #888) 50% 50% / 1px 100% no-repeat;
        }
        .value-display { min-width: 40px; text-align: center; background-color: white; padding: 2px 8px; border-radius: 4px; border: 1px solid #ccc; font-size: 20px; }
        .density-inputs { display: flex; flex-direction: column; gap: 8px; }
        .density-box { width: 30px; height: 32px; border-radius: 6px; border: 1px solid #ccc; box-sizing: border-box; margin-left: 8px; display: inline-block; vertical-align: middle; }
        .handle { width: 20px; height: 32px; margin-top: 2px; }
        .density-bar { height: clamp(12px, 2vw, 20px); }
        .density-input { display: grid; grid-template-columns: 72px 1fr auto auto; align-items: center; gap: 8px; }
        .density-input label { text-align: right; }
        .density-input input[type="range"] { min-width: 120px; }
        .density-input input[type="number"] { width: 60px; padding: 4px; border: 1px solid #ccc; border-radius: 4px; text-align: center; font-size: 10px; }

        /* 値表示の体裁を統一（div/input共通） */
        .value-display {
            display: inline-block;
            height: 32px;
            line-height: 28px; /* 視覚中央寄せ */
            font-size: 20px;
            padding: 2px 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            background-color: #fff;
            vertical-align: middle;
        }
        /* 数値入力型の value-display を他と同じ見た目に */
        .density-input input.value-display[type="number"] {
            width: 60px;            /* 既存と同幅 */
            text-align: center;
            font-size: 20px;        /* div版と揃える */
            height: 32px;           /* 高さを固定 */
            line-height: 28px;
            -moz-appearance: textfield; /* Firefox: スピン非表示 */
            font-variant-numeric: tabular-nums; /* 桁位置揃え */
            font-feature-settings: "tnum";
        }
        /* WebKit: スピンボタン非表示 */
        .density-input input.value-display[type="number"]::-webkit-outer-spin-button,
        .density-input input.value-display[type="number"]::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        .canvas-container { text-align: center; width: 100%; min-width: 320px; margin-top: 20px; }
        canvas { width: 100%; max-width: 100%; display: block; box-sizing: border-box; margin: 0 auto; border: 2px solid #333; border-radius: 8px; background-color: white; }
        #graphCanvas { width: 100%; display: block; }
        @media (min-width: 800px) { .density-box { height: 36px; } }
    </style>
</head>
<body>
    <div class="container">
        <div class="controls">
            <div class="controls-left">
                <div class="control-group">
                    <div class="density-inputs">
                        <div class="density-input">
                            <label for="startDensity">開始濃度</label>
                            <input type="range" id="startDensity" min="0" max="255" value="50" step="1">
                            <div class="value-display" id="startDensityValue">50</div>
                            <div class="density-box" id="startDensityBox"></div>
                        </div>
                        <div class="density-input">
                            <label for="endDensity">終了濃度</label>
                            <input type="range" id="endDensity" min="0" max="255" value="200" step="1">
                            <div class="value-display" id="endDensityValue">200</div>
                            <div class="density-box" id="endDensityBox"></div>
                        </div>
                    </div>
                </div>
                <div class="control-group">
                    <div class="density-inputs">
                        <!-- 解像度スライダ（200〜600）＋目印ライン＋数値ボックス -->
                        <div class="density-input" style="grid-template-columns: 72px 1fr auto;">
                            <label for="resolution">解像度</label>
                            <input type="range" id="resolution" class="range-with-marks" min="200" max="600" step="50" value="350">
                            <input type="number" class="value-display" id="resolutionValue" min="200" max="600" step="50" value="350">
                        </div>
                    </div>
                </div>
            </div>
            <div class="controls-right">
                <div class="control-group">
                    <label>強さ (Amount)</label>
                    <div class="slider-container">
                        <input type="range" id="amount" min="0" max="500" value="100" step="1">
                        <input type="number" class="value-display" id="amountValue" min="0" max="500" value="100">
                    </div>
                </div>
                <div class="control-group">
                    <label>半径 (Radius)</label>
                    <div class="slider-container">
                        <input type="range" id="radius" min="0.1" max="5" step="0.1" value="1">
                        <input type="number" class="value-display" id="radiusValue" min="0.1" max="5" step="0.1" value="1.0">
                    </div>
                </div>
                <div class="control-group">
                    <label>閾値 (Threshold)</label>
                    <div class="slider-container">
                        <input type="range" id="threshold" min="0" max="50" value="0">
                        <input type="number" class="value-display" id="thresholdValue" min="0" max="50" value="0">
                    </div>
                </div>
            </div>
        </div>
        <div class="canvas-container">
            <canvas id="graphCanvas"></canvas>
        </div>
    </div>

    <script>
        // ===== 視覚補正用パラメータ =====
const PERCEPTUAL_ALPHA   = 0.6;    // Weber重み
const PERCEPTUAL_LSCALE  = 10.0;   // ΔL* 正規化スケール
const BG_RADIUS_FACTOR   = 1.8;    // 背景平均の窓（半径×係数）
const EPSILON            = 1e-4;   // ゼロ割回避

const PERCEPTUAL_TARGET_FRAC = 1/5;  // 視覚補正カーブの最大値を抑える
const PERCEPTUAL_RANGE_MAX   = 12;   // 右側Y軸レンジ上限（固定）

// ===== sRGB→線形、線形→L*（グレイ前提） =====
function srgbToLinear(v01) {
  return (v01 <= 0.04045) ? (v01 / 12.92) : Math.pow((v01 + 0.055) / 1.055, 2.4);
}
function linearToLstar(Y) {
  const delta = 6/29;
  return (Y > Math.pow(delta,3)) ? (116 * Math.cbrt(Y) - 16)
                                 : (Y / (3*delta*delta) + 4/29) * 116 - 16;
}

// パーセンタイル
function percentile(arr, p) {
  if (!arr.length) return 0;
  const a = arr.slice().sort((x,y)=>x-y);
  const idx = Math.min(a.length - 1, Math.max(0, Math.floor((p/100) * (a.length - 1))));
  return a[idx];
}

    // 変数宣言・要素取得
    const canvas = document.getElementById('graphCanvas');
    const ctx = canvas.getContext('2d');

    // コントロール要素
    const startDensityInput = document.getElementById('startDensity');
    const endDensityInput = document.getElementById('endDensity');
    const amountSlider = document.getElementById('amount');
    const radiusSlider = document.getElementById('radius');
    const thresholdSlider = document.getElementById('threshold');
    const resolutionSlider = document.getElementById('resolution');

    // 値表示要素
    const startDensityValue = document.getElementById('startDensityValue');
    const endDensityValue = document.getElementById('endDensityValue');
    const amountValue = document.getElementById('amountValue');
    const radiusValue = document.getElementById('radiusValue');
    const thresholdValue = document.getElementById('thresholdValue');
    const resolutionValue = document.getElementById('resolutionValue');

    // 濃度ボックス要素
    const startDensityBox = document.getElementById('startDensityBox');
    const endDensityBox = document.getElementById('endDensityBox');

    // キャンバスサイズを調整する関数
    function resizeCanvas() {
        const container = canvas.parentElement;
        const dpr = window.devicePixelRatio || 1;
        const rect = container.getBoundingClientRect();
        const width = Math.floor(rect.width);

        const viewportHeight = window.innerHeight;
        const controlsHeight = document.querySelector('.controls').offsetHeight;
        const h1Height = document.querySelector('h1') ? document.querySelector('h1').offsetHeight : 0;
        const marginTop = 20;
        const extraMargin = 40;

        const availableHeight = viewportHeight - controlsHeight - h1Height - marginTop - extraMargin;

        const aspectRatio = 0.6;
        const heightByAspect = width * aspectRatio;
        const height = Math.min(600, Math.max(200, Math.min(availableHeight, heightByAspect)));

        canvas.width = width * dpr;
        canvas.height = height * dpr;
        canvas.style.width = width + 'px';
        canvas.style.height = height + 'px';

        ctx.scale(dpr, dpr);
    }

    // ガウシアンブラーのカーネル係数を生成
    function gaussianKernel(radius) {
        let sigma;
        if (radius <= 1.0) sigma = radius * 0.8 + 0.2;
        else sigma = radius * 0.6 + 0.4;

        const kernelRadius = Math.ceil(sigma * 4);
        const size = kernelRadius * 2 + 1;
        const kernel = [];
        let sum = 0;

        for (let i = -kernelRadius; i <= kernelRadius; i++) {
            const value = Math.exp(-(i * i) / (2 * sigma * sigma));
            kernel[i + kernelRadius] = value;
            sum += value;
        }
        for (let i = 0; i < size; i++) kernel[i] /= sum;
        return kernel;
    }

    // USMを適用
    function applyUSM(originalValue, blurredValue, amount, threshold) {
        const difference = originalValue - blurredValue;
        if (Math.abs(difference) < threshold) return originalValue;
        const enhancedValue = originalValue + (amount / 100.0) * difference;
        return Math.max(0, Math.min(255, Math.round(enhancedValue)));
    }

    // エッジを生成し、ぼかしを適用
    function createBlurredEdge(startDensity, endDensity, radius) {
        const width = 20;
        const gradient = [];
        const edgePosition = width / 2;

        for (let x = 0; x < width; x++) {
            const value = x < edgePosition ? startDensity : endDensity;
            gradient[x] = value;
        }

        const kernel = gaussianKernel(radius);
        const blurred = [];
        const kernelRadius = Math.floor(kernel.length / 2);

        for (let x = 0; x < width; x++) {
            let sum = 0, weightSum = 0;
            for (let k = 0; k < kernel.length; k++) {
                const sampleX = x + k - kernelRadius;
                const sampleValue =
                    sampleX < 0 ? gradient[0] :
                    sampleX >= width ? gradient[width - 1] :
                    gradient[sampleX];
                sum += sampleValue * kernel[k];
                weightSum += kernel[k];
            }
            blurred[x] = sum / weightSum;
        }
        return { original: gradient, blurred: blurred };
    }

    // メインのグラフ描画処理
    function drawGraph() {
        resizeCanvas();

        // パラメータ取得
        const startDensity = parseInt(startDensityInput.value);
        const endDensity = parseInt(endDensityInput.value);
        const amount = parseInt(amountSlider.value);
        const radius = parseFloat(radiusSlider.value);
        const threshold = parseInt(thresholdSlider.value);
        const ppi = parseInt(resolutionSlider.value) || 300;

        // 値を表示
        startDensityValue.textContent = startDensity;
        endDensityValue.textContent = endDensity;
        amountValue.value = amount;
        radiusValue.value = radius.toFixed(1);
        thresholdValue.value = threshold;
        resolutionValue.value = ppi;

        // 濃度ボックスの色
        startDensityBox.style.background = `rgb(${startDensity},${startDensity},${startDensity})`;
        endDensityBox.style.background = `rgb(${endDensity},${endDensity},${endDensity})`;

        // キャンバスクリア
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // エッジ・ぼかし
        const { original, blurred } = createBlurredEdge(startDensity, endDensity, radius);

        // USM適用
        const sharpened = [];
        for (let x = 0; x < original.length; x++) {
            sharpened[x] = applyUSM(original[x], blurred[x], amount, threshold);
        }

        // 変化量 0–12（単純）
        const change = [];
        for (let x = 0; x < original.length; x++) {
            const delta = Math.abs(sharpened[x] - original[x]); // 0..255
            change[x] = (delta / 255) * 12; // 0..12
        }

        // ===== 視覚補正版 変化量（モジュール化） =====
        // 1) 線形光Y・L*へ
        const Y_orig = original.map(v => srgbToLinear(v / 255));
        const Y_shrp = sharpened.map(v => srgbToLinear(v / 255));
        const L_orig = Y_orig.map(linearToLstar);
        const L_shrp = Y_shrp.map(linearToLstar);

        // 2) 背景平均（半径×係数）
        function blur1D(values, effRadius) {
            const r = Math.max(0.5, effRadius);
            const kernel = gaussianKernel(r);
            const out = new Array(values.length);
            const kR = Math.floor(kernel.length / 2);
            for (let x = 0; x < values.length; x++) {
                let sum = 0, wsum = 0;
                for (let k = 0; k < kernel.length; k++) {
                    const xi = x + k - kR;
                    const v  = (xi < 0) ? values[0] : (xi >= values.length ? values[values.length - 1] : values[xi]);
                    const w  = kernel[k];
                    sum += v * w; wsum += w;
                }
                out[x] = sum / wsum;
            }
            return out;
        }
        const bg = blur1D(Y_orig, radius * BG_RADIUS_FACTOR);

        // 3) Weber + ΔL*
        const C_weber = Y_orig.map((Yo, i) => Math.abs(Y_shrp[i] - Yo) / (bg[i] + EPSILON));
        const dLstar  = L_orig.map((Lo, i) => Math.abs(L_shrp[i] - Lo));

        // 4) 合成 → p95正規化で0–12
        const C_raw = C_weber.map((c,i) => PERCEPTUAL_ALPHA * c + (1 - PERCEPTUAL_ALPHA) * (dLstar[i] / PERCEPTUAL_LSCALE));
        const p95   = Math.max(EPSILON, percentile(C_raw, 95));
        const targetMax = PERCEPTUAL_RANGE_MAX * PERCEPTUAL_TARGET_FRAC; // 例えば 12 × 2/3 = 8
        const scale = targetMax / p95;
        const change_perc = C_raw.map(c => Math.min(PERCEPTUAL_RANGE_MAX, c * scale));

        // FWHM（半値全幅＝一般に「半値幅」）→ mm換算（単純／視覚補正）
        function computeFWHM(arr) {
            if (!arr || arr.length < 2) return 0;
            const maxVal = Math.max(...arr);
            if (maxVal <= 0) return 0;
            const half = maxVal / 2;
            // 左交点
            let xL = 0;
            for (let i = 1; i < arr.length; i++) {
                if ((arr[i] >= half && arr[i - 1] < half) || (arr[i] <= half && arr[i - 1] > half)) {
                    const y0 = arr[i - 1], y1 = arr[i];
                    const t = (half - y0) / ((y1 - y0) || 1e-9);
                    xL = (i - 1) + Math.max(0, Math.min(1, t));
                    break;
                }
                if (arr[i] === half && arr[i - 1] < half) { xL = i; break; }
            }
            // 右交点
            let xR = arr.length - 1;
            for (let i = arr.length - 2; i >= 0; i--) {
                if ((arr[i] >= half && arr[i + 1] < half) || (arr[i] <= half && arr[i + 1] > half)) {
                    const y0 = arr[i + 1], y1 = arr[i];
                    const t = (half - y0) / ((y1 - y0) || 1e-9);
                    xR = (i + 1) - Math.max(0, Math.min(1, t));
                    break;
                }
                if (arr[i] === half && arr[i + 1] < half) { xR = i; break; }
            }
            const fwhm = Math.max(0, xR - xL);
            return fwhm; // px
        }
        const fwhmPx = computeFWHM(change);
        const mmPerPx = 25.4 / ppi;
        const fwhmMm = fwhmPx * mmPerPx;

        // 視覚補正カーブのFWHM
        const fwhmPxPerc = computeFWHM(C_raw);  // スケーリング/クリップ前の原系列でFWHMを算出し、PERCEPTUAL_TARGET_FRACの影響を排除
        const fwhmMmPerc = fwhmPxPerc * mmPerPx;

        // グラフ領域
        const padX = 40, padY = 40;
        const graphWidth  = canvas.width / (window.devicePixelRatio || 1) - padX * 2;
        const graphHeight = canvas.height / (window.devicePixelRatio || 1) - padY * 2;
        const graphX = padX, graphY = padY;

        // 背景（20分割）
        ctx.strokeStyle = '#e0e0e0';
        ctx.lineWidth = 1;

        const cellWidth = graphWidth / 20;
        for (let i = 0; i < sharpened.length; i++) {
            const grayValue = Math.round(sharpened[i]);
            ctx.fillStyle = `rgb(${grayValue}, ${grayValue}, ${grayValue})`;
            const cellLeft = graphX + i * cellWidth;
            const cellRight = graphX + (i + 1) * cellWidth;
            ctx.fillRect(cellLeft, graphY, cellRight - cellLeft, graphHeight);
        }

        // 水平グリッド
        for (let i = 0; i <= 10; i++) {
            const y = graphY + (graphHeight / 10) * i;
            ctx.beginPath(); ctx.moveTo(graphX, y); ctx.lineTo(graphX + graphWidth, y); ctx.stroke();
        }
        // 垂直グリッド
        for (let i = 0; i <= 20; i++) {
            const x = graphX + (graphWidth / 20) * i;
            ctx.beginPath(); ctx.moveTo(x, graphY); ctx.lineTo(x, graphY + graphHeight); ctx.stroke();
        }

        // 軸（左下原点）
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(graphX, graphY);
        ctx.lineTo(graphX, graphY + graphHeight);
        ctx.lineTo(graphX + graphWidth, graphY + graphHeight);
        ctx.stroke();

        // X軸ラベル：FWHM[mm]（中央揃え・1行表示／フォント2倍）
        ctx.fillStyle = '#333';
        ctx.font = '20px Arial'; // 2倍
        ctx.textAlign = 'center';
        const baseX = graphX + graphWidth / 2;
        const baseY = graphY + graphHeight + 35;
        const baseText = fwhmMm.toFixed(3) + ' mm';
        const percText = '視覚補正 ' + fwhmMmPerc.toFixed(3) + ' mm';
        const spacer = '   '; // 視認性のための空白
        const fullText = baseText + spacer + percText;
        ctx.fillText(fullText, baseX, baseY);

        // X目盛り（0,5,10,15,20）
        ctx.fillStyle = '#666';
        ctx.font = '10px Arial';
        ctx.textAlign = 'center';
        for (let i = 0; i <= 20; i += 5) {
            const x = graphX + (graphWidth / 20) * i;
            ctx.fillText(i.toString(), x, graphY + graphHeight + 15);
        }

        // 左Y軸目盛り（濃度 0〜255）
        ctx.textAlign = 'right';
        for (let i = 0; i <= 255; i += 51) {
            const y = graphY + graphHeight - (i / 255) * graphHeight;
            ctx.fillText(i.toString(), graphX - 5, y + 3);
        }

        // 線描画（0–255）
        function drawLine(data, color, lineWidth = 2, outline = false) {
            if (outline) {
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = lineWidth + 4;
                ctx.beginPath();
                for (let i = 0; i < data.length; i++) {
                    const x = graphX + (graphWidth / (data.length - 1)) * i;
                    const y = graphY + graphHeight - (data[i] / 255) * graphHeight;
                    if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
                }
                ctx.stroke();
            }
            ctx.strokeStyle = color;
            ctx.lineWidth = lineWidth;
            ctx.beginPath();
            for (let i = 0; i < data.length; i++) {
                const x = graphX + (graphWidth / (data.length - 1)) * i;
                const y = graphY + graphHeight - (data[i] / 255) * graphHeight;
                if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
            }
            ctx.stroke();
        }

        // 任意レンジ線（0–12 用）
        function drawLineScaled(data, color, yMin, yMax, lineWidth = 2, outline = false) {
            if (outline) {
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = lineWidth + 4;
                ctx.beginPath();
                for (let i = 0; i < data.length; i++) {
                    const x = graphX + (graphWidth / (data.length - 1)) * i;
                    const y = graphY + graphHeight - ((data[i] - yMin) / (yMax - yMin)) * graphHeight;
                    if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
                }
                ctx.stroke();
            }
            ctx.strokeStyle = color;
            ctx.lineWidth = lineWidth;
            ctx.beginPath();
            for (let i = 0; i < data.length; i++) {
                const x = graphX + (graphWidth / (data.length - 1)) * i;
                const y = graphY + graphHeight - ((data[i] - yMin) / (yMax - yMin)) * graphHeight;
                if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
            }
            ctx.stroke();
        }

        // 線を描画（濃度系）
        drawLine(original,  '#999',    3);
        drawLine(blurred,   '#87CEEB', 2, true);
        drawLine(sharpened, '#FF4444', 3, true);

        // 変化量（黒＋白フチ）と視覚補正（濃い緑＋白フチ）
        drawLineScaled(change, 'black', 0, 12, 2, true);
        drawLineScaled(change_perc, '#2E8B57', 0, 12, 2, true);

        // 右側Y軸目盛り（変化量 0〜12）
        ctx.textAlign = 'left';
        ctx.fillStyle = '#333';
        ctx.font = '10px Arial';
        for (let i = 0; i <= 12; i += 2) {
            const y = graphY + graphHeight - (i / 12) * graphHeight;
            ctx.fillText(i.toString(), graphX + graphWidth + 5, y + 3);
        }
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 1;
        for (let i = 0; i <= 12; i += 2) {
            const y = graphY + graphHeight - (i / 12) * graphHeight;
            ctx.beginPath(); ctx.moveTo(graphX + graphWidth, y); ctx.lineTo(graphX + graphWidth + 3, y); ctx.stroke();
        }

        // 凡例
        const legendY = 25;
        ctx.font = '12px Arial';
        ctx.textAlign = 'left';
        ctx.fillStyle = '#999';    ctx.fillText('— 元の濃度', 80, legendY);
        ctx.fillStyle = '#87CEEB'; ctx.fillText('— ぼかした濃度', 180, legendY);
        ctx.fillStyle = '#FF4444'; ctx.fillText('— USM適用後', 300, legendY);
        ctx.fillStyle = '#000';    ctx.fillText('— 変化量(0–12)', 400, legendY);
        ctx.fillStyle = '#2E8B57'; ctx.fillText('— 視覚補正(0–12)', 520, legendY);
    }

    // イベント
    startDensityInput.addEventListener('input', drawGraph);
    endDensityInput.addEventListener('input', drawGraph);
    amountSlider.addEventListener('input', () => { amountValue.value = amountSlider.value; drawGraph(); });
    radiusSlider.addEventListener('input', () => { radiusValue.value = radiusSlider.value; drawGraph(); });
    thresholdSlider.addEventListener('input', () => { thresholdValue.value = thresholdSlider.value; drawGraph(); });
    resolutionSlider.addEventListener('input', () => {
        resolutionValue.value = resolutionSlider.value;
        drawGraph();
    });

    // 数値入力
    amountValue.addEventListener('input', () => {
        let v = Math.max(0, Math.min(500, parseInt(amountValue.value) || 0));
        amountValue.value = v; amountSlider.value = v; drawGraph();
    });
    radiusValue.addEventListener('change', () => {
        let v = parseFloat(radiusValue.value); if (isNaN(v)) return;
        v = Math.max(0.1, Math.min(5, v)); radiusValue.value = v; radiusSlider.value = v; drawGraph();
    });
    thresholdValue.addEventListener('input', () => {
        let v = Math.max(0, Math.min(50, parseInt(thresholdValue.value) || 0));
        thresholdValue.value = v; thresholdSlider.value = v; drawGraph();
    });
    resolutionValue.addEventListener('input', () => {
        let v = Math.max(200, Math.min(600, parseInt(resolutionValue.value) || 0));
        resolutionValue.value = v;
        resolutionSlider.value = v;
        drawGraph();
    });

    // リサイズ
    window.addEventListener('resize', drawGraph);

    // 初期描画
    drawGraph();
    </script>
</body>
</html>
